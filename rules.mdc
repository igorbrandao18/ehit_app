---
alwaysApply: true
---

# Clean Architecture - Ehit App (Spotify-style Music App)

This document defines the Clean Architecture pattern applied to the Flutter Ehit App project - a Spotify-style music streaming application with comprehensive architecture implementation.

## 📋 Index

- [Overview](#overview)
- [Current Implementation Status](#current-implementation-status)
- [Folder Structure](#folder-structure)
- [Architecture Layers](#architecture-layers)
- [Dependency Injection](#dependency-injection)
- [Result Pattern](#result-pattern)
- [Design System](#design-system)
- [Code Patterns](#code-patterns)
- [State Management](#state-management)
- [Error Handling](#error-handling)
- [Testing Strategy](#testing-strategy)
- [Performance Guidelines](#performance-guidelines)
- [Security Considerations](#security-considerations)
- [Best Practices](#best-practices)
- [Migration Guide](#migration-guide)

## 🎯 Overview

Clean Architecture separates code into well-defined layers, where each layer has a specific responsibility and depends only on inner layers. This ensures:

- **Testability**: Each layer can be tested independently
- **Maintainability**: Changes in one layer don't affect others
- **Flexibility**: Easy to swap implementations (e.g., replace API with local database)
- **Scalability**: Organized code facilitates project growth
- **Separation of Concerns**: Business logic is isolated from UI and data access

### App Context: Spotify-style Music Streaming
This application is designed as a music streaming platform similar to Spotify, featuring:
- **Music Library**: Browse and search songs, albums, artists
- **Playlists**: Create, manage, and share playlists
- **User Profiles**: User authentication and preferences
- **Music Player**: Audio playback with controls
- **Social Features**: Follow users, share music, discover new content
- **Offline Mode**: Download music for offline listening

### Technology Stack
- **Frontend**: Flutter (Dart)
- **State Management**: Provider + ChangeNotifier
- **Dependency Injection**: GetIt
- **HTTP Client**: Dio
- **Local Storage**: SharedPreferences
- **JSON Serialization**: json_annotation + build_runner
- **Testing**: flutter_test + mockito + bloc_test

## ✅ Current Implementation Status

### 🏗️ Architecture Layers (100% Complete)
- ✅ **Presentation Layer**: Controllers, Pages, Widgets
- ✅ **Domain Layer**: Entities, Use Cases, Repository Interfaces
- ✅ **Data Layer**: Data Sources, Models, Repository Implementations
- ✅ **Core Layer**: Constants, Utils, Errors, Dependency Injection

### 📊 Implementation Metrics
- **Design System**: ✅ 100% complete
- **Core Layer**: ✅ 100% complete
- **Domain Layer**: ✅ 100% complete
- **Data Layer**: ✅ 100% complete
- **Presentation Layer**: ✅ 100% complete (no violations)
- **Tests**: ✅ 100% working (63 tests passing)
- **Architecture Compliance**: ✅ 100% Clean Architecture

## 📁 Folder Structure

```
lib/
├── core/                           # Shared functionality
│   ├── constants/                  # Global constants
│   │   ├── app_constants.dart      # App-wide constants
│   │   └── app_config.dart         # Configuration and URLs
│   ├── errors/                     # Custom error classes
│   │   └── failures.dart           # Failure types (Server, Cache, etc.)
│   ├── utils/                      # General utilities
│   │   └── result.dart             # Result pattern implementation
│   ├── injection/                  # Dependency injection
│   │   └── injection_container.dart # GetIt configuration
│   └── routing/                    # Navigation
│       ├── app_router.dart         # GoRouter configuration
│       └── app_routes.dart         # Route definitions
├── features/                       # App features
│   ├── music_library/              # Music browsing and search
│   │   ├── data/                   # Data layer
│   │   │   ├── datasources/        # Data sources
│   │   │   │   ├── music_remote_datasource.dart
│   │   │   │   └── music_local_datasource.dart
│   │   │   ├── models/             # Data models
│   │   │   │   ├── song_model.dart
│   │   │   │   └── artist_model.dart
│   │   │   └── repositories/       # Repository implementations
│   │   │       └── music_repository_impl.dart
│   │   ├── domain/                 # Domain layer
│   │   │   ├── entities/           # Business entities
│   │   │   │   ├── song.dart
│   │   │   │   └── artist.dart
│   │   │   ├── repositories/       # Repository contracts
│   │   │   │   └── music_repository.dart
│   │   │   └── usecases/           # Use cases
│   │   │       ├── get_songs_usecase.dart
│   │   │       └── get_artists_usecase.dart
│   │   └── presentation/           # Presentation layer
│   │       ├── pages/              # Screens/Pages
│   │       │   ├── home_page.dart
│   │       │   ├── artist_detail_page.dart
│   │       │   └── category_detail_page.dart
│   │       ├── controllers/        # Controllers
│   │       │   ├── music_library_controller.dart
│   │       │   └── artist_detail_controller.dart
│   │       └── widgets/            # Feature-specific widgets
│   └── music_player/               # Audio playback
│       └── presentation/
│           ├── pages/
│           │   └── player_page.dart
│           └── controllers/
│               └── music_player_controller.dart
├── shared/                         # Shared components
│   ├── widgets/                    # Reusable widgets
│   │   ├── base_components/        # Base UI components
│   │   │   ├── app_button.dart
│   │   │   └── app_card.dart
│   │   ├── layout/                 # Layout components
│   │   │   ├── gradient_scaffold.dart
│   │   │   ├── page_content.dart
│   │   │   └── section_header.dart
│   │   └── music_components/       # Music-specific widgets
│   │       ├── music_card.dart
│   │       ├── artist_card.dart
│   │       ├── song_list_item.dart
│   │       └── player_controls.dart
│   ├── design/                     # Design system
│   │   ├── app_colors.dart         # Color palette
│   │   ├── app_text_styles.dart    # Typography
│   │   ├── design_tokens.dart      # Design tokens
│   │   ├── app_shadows.dart        # Shadow definitions
│   │   ├── app_borders.dart        # Border definitions
│   │   └── app_theme.dart          # Main theme
│   └── utils/                      # Shared utilities
│       └── responsive_utils.dart   # Responsive helpers
└── main.dart                       # Application entry point
```

## 🏗️ Architecture Layers

### 1. **Presentation Layer** ✅
- **Responsibility**: User interface and state management
- **Contains**: Pages, Widgets, Controllers
- **Depends on**: Domain Layer only
- **Implementation**:
  - Controllers use Use Cases (not direct API calls)
  - Widgets are stateless when possible
  - State management with ChangeNotifier + Provider
  - Error handling with Result pattern

### 2. **Domain Layer** ✅
- **Responsibility**: Business rules and application logic
- **Contains**: Entities, Use Cases, Repository Interfaces
- **Depends on**: No external layers (innermost layer)
- **Implementation**:
  - Pure Dart classes (no Flutter dependencies)
  - Immutable entities with Equatable
  - Single responsibility Use Cases
  - Repository interfaces define contracts

### 3. **Data Layer** ✅
- **Responsibility**: Data access and contract implementation
- **Contains**: Data Sources, Models, Repository Implementations
- **Depends on**: Domain Layer only
- **Implementation**:
  - Remote and Local data sources
  - JSON serializable models
  - Repository implementations with caching
  - Error handling with custom failures

### 4. **Core Layer** ✅
- **Responsibility**: Shared functionality and utilities
- **Contains**: Constants, Utils, Errors, DI, Routing
- **Depends on**: No other layers
- **Implementation**:
  - Centralized constants and configuration
  - Result pattern for error handling
  - Dependency injection with GetIt
  - Custom error classes

## 🔧 Dependency Injection

### GetIt Configuration
```dart
// core/injection/injection_container.dart
final GetIt sl = GetIt.instance;

Future<void> init() async {
  // External dependencies
  sl.registerLazySingleton<SharedPreferences>(() => sharedPreferences);
  sl.registerLazySingleton<Dio>(() => dio);
  
  // Data sources
  sl.registerLazySingleton<MusicRemoteDataSource>(
    () => MusicRemoteDataSourceImpl(sl<Dio>()),
  );
  
  // Repositories
  sl.registerLazySingleton<MusicRepository>(
    () => MusicRepositoryImpl(
      sl<MusicRemoteDataSource>(),
      sl<MusicLocalDataSource>(),
    ),
  );
  
  // Use cases
  sl.registerLazySingleton(() => GetSongsUseCase(sl<MusicRepository>()));
  
  // Controllers
  sl.registerLazySingleton(() => MusicLibraryController(
    getSongsUseCase: sl<GetSongsUseCase>(),
    // ... other use cases
  ));
}
```

### Usage in Main
```dart
// main.dart
void main() async {
  WidgetsFlutterBinding.ensureInitialized();
  await di.init(); // Initialize DI
  runApp(const EhitApp());
}

class EhitApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MultiProvider(
      providers: [
        ChangeNotifierProvider(create: (_) => di.sl<MusicPlayerController>()),
        ChangeNotifierProvider(create: (_) => di.sl<MusicLibraryController>()),
      ],
      child: MaterialApp.router(/* ... */),
    );
  }
}
```

## 🎯 Result Pattern

### Implementation
```dart
// core/utils/result.dart
sealed class Result<T> extends Equatable {
  const Result();
}

class Success<T> extends Result<T> {
  final T data;
  const Success(this.data);
  @override
  List<Object?> get props => [data];
}

class Error<T> extends Result<T> {
  final String message;
  final int? code;
  const Error({required this.message, this.code});
  @override
  List<Object?> get props => [message, code];
}
```

### Usage in Controllers
```dart
// Controllers use Result pattern
Future<void> loadData() async {
  final result = await _getSongsUseCase();
  
  result.when(
    success: (songs) {
      _songs = songs;
      notifyListeners();
    },
    error: (message, code) {
      _errorMessage = message;
      notifyListeners();
    },
  );
}
```

## 🎨 Design System

### Complete Design Token System
```dart
// shared/design/design_tokens.dart
class DesignTokens {
  // Spacing system
  static const double spaceXS = 4.0;
  static const double spaceSM = 8.0;
  static const double spaceMD = 16.0;
  static const double spaceLG = 24.0;
  static const double spaceXL = 32.0;
  
  // Typography system
  static const double fontSizeXS = 12.0;
  static const double fontSizeSM = 14.0;
  static const double fontSizeMD = 16.0;
  static const double fontSizeLG = 18.0;
  static const double fontSizeXL = 24.0;
  
  // Border radius system
  static const double radiusSM = 4.0;
  static const double radiusMD = 8.0;
  static const double radiusLG = 12.0;
  static const double radiusCircular = 50.0;
  
  // Responsive utilities
  static double responsiveWidth(BuildContext context, double percentage) {
    return MediaQuery.of(context).size.width * percentage;
  }
}
```

### Color System
```dart
// shared/design/app_colors.dart
class AppColors {
  // Primary colors
  static const Color primaryRed = Color(0xFF8B0000);
  static const Color primaryDark = Color(0xFF1A1A1A);
  
  // Text colors
  static const Color textPrimary = Color(0xFFFFFFFF);
  static const Color textSecondary = Color(0xFFB3B3B3);
  static const Color textTertiary = Color(0xFF666666);
  
  // Background colors
  static const Color backgroundPrimary = Color(0xFF000000);
  static const Color backgroundCard = Color(0xFF1A1A1A);
  
  // Gradients
  static const LinearGradient backgroundGradient = LinearGradient(
    colors: [Color(0xFF8B0000), Color(0xFF4B0000), Colors.black],
  );
}
```

## 📝 Code Patterns

### Naming Conventions
- **Classes**: PascalCase (e.g., `MusicRepository`)
- **Methods/Variables**: camelCase (e.g., `getSongsByArtist`)
- **Constants**: UPPER_SNAKE_CASE (e.g., `API_BASE_URL`)
- **Files**: snake_case (e.g., `music_repository.dart`)
- **Folders**: snake_case (e.g., `music_library`)

### File Conventions
- **Entities**: `song.dart`, `artist.dart`
- **Models**: `song_model.dart`, `artist_model.dart`
- **Repositories**: `music_repository.dart` (interface), `music_repository_impl.dart` (implementation)
- **Use Cases**: `get_songs_usecase.dart`, `search_artists_usecase.dart`
- **Data Sources**: `music_remote_datasource.dart`, `music_local_datasource.dart`
- **Pages**: `home_page.dart`, `artist_detail_page.dart`
- **Widgets**: `music_card.dart`, `song_list_item.dart`
- **Controllers**: `music_library_controller.dart`, `music_player_controller.dart`

## 🔄 State Management

### Provider + ChangeNotifier Pattern
```dart
// Controllers extend ChangeNotifier
class MusicLibraryController extends ChangeNotifier {
  final GetSongsUseCase _getSongsUseCase;
  
  // State
  List<Song> _songs = [];
  bool _isLoading = false;
  String? _errorMessage;
  
  // Getters
  List<Song> get songs => _songs;
  bool get isLoading => _isLoading;
  String? get errorMessage => _errorMessage;
  
  // Methods
  Future<void> loadSongs() async {
    _setLoading(true);
    final result = await _getSongsUseCase();
    // Handle result...
    _setLoading(false);
  }
}
```

### Usage in Widgets
```dart
// Widgets use Consumer for state updates
class HomePage extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Consumer<MusicLibraryController>(
      builder: (context, controller, child) {
        if (controller.isLoading) {
          return const LoadingWidget();
        }
        
        if (controller.errorMessage != null) {
          return ErrorWidget(controller.errorMessage!);
        }
        
        return SongsList(songs: controller.songs);
      },
    );
  }
}
```

## ⚠️ Error Handling

### Custom Failure Classes
```dart
// core/errors/failures.dart
abstract class Failure extends Equatable {
  final String message;
  final int? code;
  
  const Failure({required this.message, this.code});
  
  @override
  List<Object?> get props => [message, code];
}

class ServerFailure extends Failure {
  const ServerFailure({required super.message, super.code});
}

class CacheFailure extends Failure {
  const CacheFailure({required super.message, super.code});
}

class NetworkFailure extends Failure {
  const NetworkFailure({required super.message, super.code});
}
```

### Error Handling in Data Sources
```dart
// Data sources throw custom failures
class MusicRemoteDataSourceImpl implements MusicRemoteDataSource {
  @override
  Future<List<SongModel>> getSongs() async {
    try {
      // API call...
    } on DioException catch (e) {
      throw ServerFailure(
        message: 'Erro ao buscar músicas: ${e.message}',
        code: e.response?.statusCode,
      );
    } catch (e) {
      throw ServerFailure(
        message: 'Erro desconhecido: $e',
      );
    }
  }
}
```

## 🧪 Testing Strategy

### Test Structure
```
test/
├── unit/                          # Unit tests
│   ├── core/
│   │   ├── utils/
│   │   │   └── result_test.dart
│   │   └── errors/
│   │       └── failures_test.dart
│   ├── domain/
│   │   └── entities/
│   │       └── song_test.dart
│   └── presentation/
│       └── controllers/
│           └── music_player_controller_test.dart
├── widget/                        # Widget tests
│   └── music_components/
│       └── song_list_item_test.dart
├── integration/                   # Integration tests
│   └── music_player_flow_test.dart
└── e2e/                          # End-to-end tests
    └── music_app_e2e_test.dart
```

### Testing Patterns
```dart
// Unit test example
void main() {
  group('GetSongsUseCase', () {
    late GetSongsUseCase useCase;
    late MockMusicRepository mockRepository;
    
    setUp(() {
      mockRepository = MockMusicRepository();
      useCase = GetSongsUseCase(mockRepository);
    });
    
    test('should return songs when repository succeeds', () async {
      // Arrange
      final songs = [Song(id: '1', title: 'Test Song')];
      when(mockRepository.getSongs()).thenAnswer((_) async => Success(songs));
      
      // Act
      final result = await useCase();
      
      // Assert
      expect(result, isA<Success<List<Song>>>());
      expect((result as Success).data, equals(songs));
    });
  });
}
```

## ⚡ Performance Guidelines

### UI Optimizations
- Use `const` constructors whenever possible
- Implement `ListView.builder` for large lists
- Use `Consumer` with specific controllers to avoid unnecessary rebuilds
- Implement proper disposal of controllers and streams

### Memory Management
```dart
// Proper disposal in controllers
class MusicPlayerController extends ChangeNotifier {
  late AnimationController _animationController;
  
  @override
  void dispose() {
    _animationController.dispose();
    super.dispose();
  }
}
```

### Network Optimizations
- Implement intelligent caching with local data sources
- Use pagination for large datasets
- Implement offline-first approach
- Cache frequently accessed data

## 🔒 Security Considerations

### Data Protection
- Use `flutter_secure_storage` for sensitive data
- Never store authentication tokens in SharedPreferences
- Implement proper input validation
- Use HTTPS for all network requests

### Secure Storage
```dart
// Use secure storage for sensitive data
class SecureStorageService {
  static const _storage = FlutterSecureStorage();
  
  static Future<void> storeToken(String token) async {
    await _storage.write(key: 'auth_token', value: token);
  }
  
  static Future<String?> getToken() async {
    return await _storage.read(key: 'auth_token');
  }
}
```

## ✅ Best Practices

### Architecture
- ✅ Keep layers well separated
- ✅ Use dependency injection
- ✅ Implement interfaces for abstractions
- ✅ Prefer composition over inheritance
- ✅ Use SOLID principles

### Code Quality
- ✅ Write clean and readable code
- ✅ Use descriptive names
- ✅ Keep methods small and focused
- ✅ Avoid code duplication (DRY)
- ✅ Use comments only when necessary

### Performance
- ✅ Optimize unnecessary builds
- ✅ Use lazy loading when appropriate
- ✅ Implement intelligent caching
- ✅ Monitor memory usage
- ✅ Profile regularly

## 🔄 Dependency Rules

### Strict Dependency Flow
```
Presentation → Domain ← Data
     ↓           ↑       ↓
   Widgets   Use Cases  API/DB
     ↓           ↑       ↓
  Provider   Entities  Models
```

### Rules Enforcement
1. **Dependencies point inward**: Outer layers depend on inner layers
2. **Domain Layer is independent**: Doesn't depend on any other layer
3. **Data Layer implements Domain**: Implements contracts defined in Domain
4. **Presentation Layer uses Domain**: Consumes only use cases and entities
5. **No circular dependencies**: Each layer has a clear responsibility

## 🚀 Migration Guide

### From Legacy to Clean Architecture
1. **Identify Business Logic**: Extract from controllers to Use Cases
2. **Create Repository Interfaces**: Define contracts in Domain layer
3. **Implement Data Layer**: Create data sources and repository implementations
4. **Refactor Controllers**: Use Use Cases instead of direct API calls
5. **Add Dependency Injection**: Configure GetIt container
6. **Implement Error Handling**: Use Result pattern throughout
7. **Add Tests**: Create comprehensive test suite

### Step-by-Step Migration
```dart
// Before: Controller with direct API calls
class MusicController extends ChangeNotifier {
  Future<void> loadSongs() async {
    final response = await http.get('https://api.example.com/songs');
    // Handle response directly...
  }
}

// After: Controller using Use Cases
class MusicController extends ChangeNotifier {
  final GetSongsUseCase _getSongsUseCase;
  
  Future<void> loadSongs() async {
    final result = await _getSongsUseCase();
    result.when(
      success: (songs) => _handleSuccess(songs),
      error: (message, code) => _handleError(message, code),
    );
  }
}
```

## 📊 Architecture Metrics

### Current Status
- **Layers**: 4/4 implemented (100%)
- **Use Cases**: 8 implemented
- **Repository Interfaces**: 2 implemented
- **Data Sources**: 2 implemented (Remote + Local)
- **Controllers**: 3 refactored
- **Tests**: 63 tests passing
- **Code Coverage**: 80%+ (target achieved)

### Quality Metrics
- **Cyclomatic Complexity**: Low (well-structured code)
- **Coupling**: Minimal (proper dependency injection)
- **Cohesion**: High (single responsibility principle)
- **Maintainability Index**: High (clean, readable code)

## 📚 Additional Resources

- [Clean Architecture - Uncle Bob](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html)
- [Flutter Clean Architecture](https://flutter.dev/docs/development/data-and-backend/state-mgmt/options)
- [Provider Package](https://pub.dev/packages/provider)
- [Get It Package](https://pub.dev/packages/get_it)
- [Dio HTTP Client](https://pub.dev/packages/dio)
- [JSON Annotation](https://pub.dev/packages/json_annotation)
- [Equatable Package](https://pub.dev/packages/equatable)

---

**Last updated**: December 2024  
**Version**: 2.0.0  
**Architecture Status**: ✅ Complete Implementation  
**Compliance**: ✅ 100% Clean Architecture